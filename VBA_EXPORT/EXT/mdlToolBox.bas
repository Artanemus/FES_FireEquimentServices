Attribute VB_Name = "mdlToolBox"
Option Compare Database
'@Folder "MODULE"
Option Explicit

'******************** Declare API **************************
' Declare for call to mpr.dll.
Private Declare PtrSafe Function WNetGetUser Lib "mpr.dll" _
Alias "WNetGetUserA" (ByVal lpName As String, _
ByVal lpUserName As String, lpnLength As Long) As Long
Const NoError = 0                                'The Function call was successful
Const ModuleName As String = "mdlToolBox"
Private vReturnValue As Variant

Public Property Let ReturnValue(X As Variant)
    vReturnValue = X
End Property

Public Property Get ReturnValue() As Variant
    ReturnValue = vReturnValue
End Property

Public Function LUCompanyInfoID() As Long
    LUCompanyInfoID = 1
End Function

'               (Not myArray)   (Not Not myArray)
'Uninitialized       -1                 0
'Initialized    -someBigNumber   someOtherBigNumber

Public Function IsArrayEmpty(Arr As Variant) As Boolean
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
' IsArrayEmpty
' This function tests whether the array is empty (unallocated). Returns TRUE or FALSE.
'
' The VBA IsArray function indicates whether a variable is an array, but it does not
' distinguish between allocated and unallocated arrays. It will return TRUE for both
' allocated and unallocated arrays. This function tests whether the array has actually
' been allocated.
'
' This function is really the reverse of IsArrayAllocated.
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

    Dim LB As Long
    Dim UB As Long

    err.Clear
    On Error Resume Next
    If IsArray(Arr) = False Then
        ' we weren't passed an array, return True
        IsArrayEmpty = True
    End If

    ' Attempt to get the UBound of the array. If the array is
    ' unallocated, an error will occur.
    UB = UBound(Arr, 1)
    If (err.Number <> 0) Then
        IsArrayEmpty = True
    Else
        ''''''''''''''''''''''''''''''''''''''''''
        ' On rare occasion, under circumstances I
        ' cannot reliably replicate, Err.Number
        ' will be 0 for an unallocated, empty array.
        ' On these occasions, LBound is 0 and
        ' UBound is -1.
        ' To accommodate the weird behavior, test to
        ' see if LB > UB. If so, the array is not
        ' allocated.
        ''''''''''''''''''''''''''''''''''''''''''
        err.Clear
        LB = LBound(Arr)
        If LB > UB Then
            IsArrayEmpty = True
        Else
            IsArrayEmpty = False
        End If
    End If

End Function

'Function purpose:  To Browser for a user selected folder.
'If the "OpenAt" path is provided, open the browser at that directory
'NOTE:  If invalid, it will open at the Desktop level
Function BrowseForFolder(Optional OpenAt As Variant) As Variant
    Dim msg As String
    Dim ShellApp As Object
     
    On Error GoTo PROC_ERR
    
    ' DEFAULT: returns null on error
    BrowseForFolder = vbNull

     'Create a file browser window at the default folder
    Set ShellApp = CreateObject("Shell.Application"). _
    BrowseForFolder(0, "Please choose a folder", 0, OpenAt)

     'Set the folder to that selected.  (On error in case cancelled)
    BrowseForFolder = ShellApp.self.Path

     'Check for invalid or non-entries and send to the Invalid error
     'handler if found
     'Valid selections can begin L: (where L is a letter) or
     '\\ (as in \\servername\sharename.  All others are invalid
    Select Case Mid(BrowseForFolder, 2, 1)
    Case Is = ":"
        If Left(BrowseForFolder, 1) = ":" Then GoTo PROC_ERR
    Case Is = "\"
        If Not Left(BrowseForFolder, 1) = "\" Then GoTo PROC_ERR
    Case Else
        GoTo PROC_ERR
    End Select
    
PROC_EXIT:
    If Not ShellApp Is Nothing Then
         'Destroy the Shell Application
        Set ShellApp = Nothing
    End If
    
    On Error Resume Next
    Exit Function

PROC_ERR:
    If err.Number <> 0 Then
        msg = ModuleName & " BrowseForFolder" & vbCrLf & _
              "Error # " & CStr(err.Number) & " was generated by " & err.SOURCE & vbCrLf & err.Description
        MsgBox msg, , "Error", err.HelpFile, err.HelpContext
    End If
    Resume PROC_EXIT
    
End Function


' BETTER LOOKING FUNCTION - REQUIRES COM Microsoft.Office[version number] object library

'Function BrowseFolder(Title As String, _
'    Optional InitialFolder As String = vbNullString, _
'    Optional InitialView As Office.MsoFileDialogView = _
'        msoFileDialogViewList) As String
'
'Dim V As Variant
'Dim InitFolder As String
'
'With Application.FileDialog(msoFileDialogFolderPicker)
'    .Title = Title
'    .InitialView = InitialView
'    If Len(InitialFolder) > 0 Then
'        If Dir(InitialFolder, vbDirectory) <> vbNullString Then
'            InitFolder = InitialFolder
'            If Right(InitFolder, 1) <> "\" Then
'                InitFolder = InitFolder & "\"
'            End If
'            .InitialFileName = InitFolder
'        End If
'    End If
'    .Show
'    On Error Resume Next
'    err.Clear
'    V = .SelectedItems(1)
'    If err.Number <> 0 Then
'        V = vbNullString
'    End If
'End With
'BrowseFolder = CStr(V)
'End Function

' -------------------------------------------------------------------------
' Using the OS Login Name - finds the user's Administration name and email.
' ON ERROR: returns VbNullString
' TODO: use dbo scalar function to find the best user email address
' -------------------------------------------------------------------------
Public Function GetUser_AdminEmailAddress(ByRef AdminName As String) As String
    Dim v As Variant, v1 As Variant, v2 As Variant
    Dim s As String
    Dim mSender_FName As String
    Dim mSender_HRID As Long
    
    GetUser_AdminEmailAddress = vbNullString
    AdminName = vbNullString
    ' ---------------------------------
    ' Office administrator HRID
    ' ---------------------------------
    s = mdlToolBox.GetUserName
    ' double quotes are used to handle 'spaces'
    v = DLookup("[HRID]", "dbo_HR", "[UserLoginName] = """ & s & """")
    If Nz(v, 0) > 0 Then
        mSender_HRID = CLng(v)
            v1 = DLookup("[FirstName]", "dbo_HR", "[HRID] = " & CStr(v))
            v2 = DLookup("[LastName]", "dbo_HR", "[HRID] = " & CStr(v))
            AdminName = CStr(Nz(v1, "")) & " " & CStr(Nz(v2, ""))
        ' ---------------------------------
        ' Office administrator WORK EMAIL
        ' ---------------------------------
        ' EmailType is WORK
        v = DLookup("Email", "dbo_HREmail", "[EmailTypeID] = 1 AND [HRID] = " & CStr(mSender_HRID))
        If Len(Nz(v, "")) > 0 Then
            GetUser_AdminEmailAddress = CStr(v)
        End If
    End If
    
End Function

'Microsofts version of GetUserName - calling mpr.dll
Public Function GetUserName() As String

    ' Buffer size for the return string.
    Const lpnLength As Integer = 255

    ' Get return buffer space.
    Dim Status As Integer

    ' For getting user information.
    Dim lpName, lpUserName As String

    ' Assign the buffer size constant to lpUserName.
    lpUserName = Space$(lpnLength + 1)

    ' Get the log-on name of the person using product.
    Status = WNetGetUser(lpName, lpUserName, lpnLength)

    ' See whether error occurred.
    If Status = NoError Then
        ' This line removes the null character. Strings in C are null-
        ' terminated. Strings in Visual Basic are not null-terminated.
        ' The null character must be removed from the C strings to be used
        ' cleanly in Visual Basic.
        lpUserName = Left$(lpUserName, InStr(lpUserName, Chr(0)) - 1)
    Else

        ' An error occurred.
        'MsgBox "Unable to get the name."
        GetUserName = vbNullString
        End
    End If

    ' Display the name of the person logged on to the machine.
    'MsgBox "The person logged on this machine is: " & lpUserName
    GetUserName = lpUserName

End Function

Public Function GetBatchPrintRootPath() As String
    Dim v As Variant
    Dim RootPath As Variant
    GetBatchPrintRootPath = vbNullString
    ' Find the globals
    v = DLookup("[GlobalID]", "dbo_CompanyInfo", "[CompanyInfoID] = 1")
    If Not IsNull(v) Then
        ' get the output export path (part)
        RootPath = DLookup("[RootPathBatchReports]", "dbo_Global", "[GlobalID] = " & CLng(v))
        If IsNull(RootPath) Then
            MsgBox "The Root-Path for printing batch reports couldn't be found! Check FES Globals.", vbOKOnly Or VbMsgBoxStyle.vbCritical, "Batch Print"
            Exit Function                        ' UNEXPECTED ERROR
        End If
        ' check for trailing character
        If Not Right$(RootPath, 1) = "\" Then
            RootPath = RootPath & "\"
        End If
        ' test if this root path exists
        If Len(Dir(RootPath, vbDirectory)) = 0 Then
            MsgBox "Missing output path for batch reports." & vbCrLf & _
            "The path " & RootPath & "  must exist!", vbOKOnly Or VbMsgBoxStyle.vbCritical, "Batch Print"
            Exit Function
        End If
    Else
        MsgBox "No Company Info!", vbOKOnly Or VbMsgBoxStyle.vbCritical, "Batch Print"
        Exit Function                            ' UNEXPECTED ERROR
    End If
    GetBatchPrintRootPath = RootPath
End Function

Public Function AdjustDTCeiling(Value As Variant) As Variant
    Dim dt As Date
    Dim msg As String

    On Error GoTo PROC_ERR

    AdjustDTCeiling = Null
    If (Not IsNull(Value)) Then
        If (Value > 0) Then
            dt = DateSerial(Year(Value), Month(Value), Day(Value))
            dt = DateAdd("h", 23, dt)
            dt = DateAdd("n", 59, dt)
            AdjustDTCeiling = dt
        End If
    End If
    
PROC_EXIT:
    On Error Resume Next
    Exit Function

PROC_ERR:
    If err.Number <> 0 Then
        msg = "AdjustDTCeiling # " & str(err.Number) & " was generated by " & err.SOURCE & vbCrLf & err.Description
        MsgBox msg, , "Error", err.HelpFile, err.HelpContext
    End If
    GoTo PROC_EXIT
    
End Function



Public Function LULogCallerID(ByVal aModuleName As String) As Long
Dim v As Variant
    LULogCallerID = 0
    v = DLookup("[LogCallerID]", "dbo_LogCaller", "[Caption] LIKE '%" & aModuleName & "%'")
    If Not IsNull(v) Then
        LULogCallerID = CLng(v)
    Else
        LULogCallerID = 0
    End If
End Function

Public Function MilitaryTime(aTime As Variant) As String
    Dim dtmMilitary As String
    dtmMilitary = vbNullString
    If Nz(aTime, 0) > 0 Then
        If Hour(aTime) < 10 Then
            dtmMilitary = "0" & Format(aTime, "hhnn")
        Else
            dtmMilitary = Format(aTime, "hhnn")
        End If
    End If
End Function



'Private Property Get HasParent(ByRef f As Form) As Boolean
'    HasParent = False
'    On Error GoTo handler
'    HasParent = TypeName(f.Parent.Name) = "String"
'    Exit Property
'handler:
'End Property

Public Function IsLoaded(ByVal strFormName As String) As Boolean
    ' Returns True if the specified form is open in Form view or Datasheet view.
    Dim oAccessObject As AccessObject
    
    On Error GoTo err_Exit

    Set oAccessObject = CurrentProject.AllForms(strFormName)
    If oAccessObject.IsLoaded Then
        If oAccessObject.CurrentView <> acCurViewDesign Then
            IsLoaded = True
        End If
    End If
    
err_Proc:
    On Error Resume Next
    Exit Function
    
err_Exit:
    IsLoaded = False
    GoTo err_Proc
    
End Function

Public Function CleanContactNum(aContactNum As String) As String
Dim rtnNumber As String
Dim msg As String

    On Error GoTo PROC_ERR
    
    'cleanup the phone number
    CleanContactNum = aContactNum
    rtnNumber = mdlToolBox.NumericOnly(aContactNum)
    If Len(rtnNumber) > 10 Then
        rtnNumber = Format(rtnNumber, "(+#) 00 0000 0000")
    ElseIf Len(rtnNumber) > 8 Then
        rtnNumber = Format(rtnNumber, "00 0000 0000")
    Else
        rtnNumber = Format(rtnNumber, "0000 0000")
    End If
    CleanContactNum = rtnNumber
    
PROC_EXIT:
    On Error Resume Next
    Exit Function

PROC_ERR:
    ' display the system error
    If err.Number <> 0 Then
        msg = ModuleName & " CleanContactNum" & vbCrLf & _
              "Error # " & CStr(err.Number) & " was generated by " & err.SOURCE & vbCrLf & err.Description
        MsgBox msg, , "Error", err.HelpFile, err.HelpContext
    End If
    
    Resume PROC_EXIT
    
End Function

Public Sub RequeryFormAndKeepCurrSelectedRecord(f As Form)
    Dim Position As Long
    Position = f.CurrentRecord
    f.Requery
    If Position > 1 Then
        f.Recordset.Move Position - 1
    End If
End Sub

Function AlphaNumericOnly(strSource As String) As String
    Dim i As Integer
    Dim strResult As String

    For i = 1 To Len(strSource)
        Select Case Asc(Mid(strSource, i, 1))
        Case 48 To 57, 65 To 90, 97 To 122:      'include 32 if you want to include space
            strResult = strResult & Mid(strSource, i, 1)
        End Select
    Next
    AlphaNumericOnly = strResult
End Function

'
' Skips all characters in the input string except digits
'
Function NumericOnly(ByVal s As String) As String
    Dim char As String
    Dim i As Integer
    NumericOnly = vbNullString
    For i = 1 To Len(s)
        char = Mid(s, i, 1)
        If char >= "0" And char <= "9" Then
            NumericOnly = NumericOnly + char
        End If
    Next i
End Function

Public Sub Form_DynamicResize(aForm As Form)
    'Me. was replaced with aForm.
    ''If Not mPassed Then Exit Sub

    'Variables
    Dim lngCount As Long
    Dim lngWindowHeight As Long
    Dim lngOldWindowHeight As Long
    Dim lngDeltaTop As Long
    Dim lngMaxRecordsToShow As Long
    Dim lngMinRecordsToShow As Long

    lngMaxRecordsToShow = 20
    lngMinRecordsToShow = 15

    'Find the amount of records in form
    Dim rst As DAO.Recordset
    Set rst = aForm.RecordsetClone
    If Not rst.EOF Then rst.MoveLast
    lngCount = rst.RecordCount

    'Assert Minimum height
    If lngCount <= lngMinRecordsToShow Then lngCount = lngMinRecordsToShow

    'Check whether there are more then Max amount of records
    If lngCount > lngMaxRecordsToShow Then
        lngCount = lngMaxRecordsToShow
        'Enable vertical scrollbar
        aForm.ScrollBars = 2                     'Vertical
    Else
        'Disable scrollbars
        aForm.ScrollBars = 0                     'None
    End If

    'Calculate new windowheight.
    'If you do not have a header/footer, or they are not visible adjust accordingly
    lngWindowHeight = aForm.FormHeader.Height + _
                      aForm.Detail.Height * lngCount + _
                      aForm.FormFooter.Height + _
                      567
    'The 567 is to account for title bar Height.
    'If you use thin border, adjust accordingly

    'The form will be "shortened" and we need to adjust the top property as well to keep it properly centered
    lngOldWindowHeight = aForm.WindowHeight
    lngDeltaTop = (lngOldWindowHeight - lngWindowHeight) / 2

    'Use the move function to move the form

    aForm.Move aForm.WindowLeft, aForm.WindowTop + lngDeltaTop, , lngWindowHeight

    'Cleanup
    Set rst = Nothing
End Sub


Public Function BuildArrayOfServiceIntervals(ByRef ArrayOfServiceIntervals() As Double, ByVal errMsg As String, ByVal LogCallerID As Long) As Boolean
    Dim SQL As String
    Dim rst As DAO.Recordset
    Dim msg As String
    Dim Failed As Boolean
    Dim str As String
    Dim v As Variant
    Dim i As Integer
    
    
    On Error GoTo PROC_ERR
    BuildArrayOfServiceIntervals = False ' FAILED
    Failed = False
    errMsg = vbNullString
    
    str = "Check that the dbo_EquipType table is correctly assigned."

    ' #### collect the service intervals being used
    SQL = _
        "SELECT dbo_EquipType.ServiceInterval FROM dbo_EquipType GROUP BY dbo_EquipType.ServiceInterval HAVING (((dbo_EquipType.ServiceInterval) Is Not Null));"
    Set rst = CurrentDb.OpenRecordset(SQL, dbOpenSnapshot, dbFailOnError + dbSeeChanges)
    i = 0
    If rst.RecordCount > 0 Then
        ' count the number of service intervals
        Do While Not rst.EOF
            If rst.Fields("ServiceInterval") > 0 Then
                i = i + 1
            End If
        rst.MoveNext
        Loop
        ' EMPTY ARRAY ? - SET DYNAMIC ?
        ' TRIM UPPER BOUNDS to account for element ARRAY(0)
        i = i - 1
        ReDim ArrayOfServiceIntervals(i)
        i = 0
        rst.MoveFirst
        ' fill the array
        Do While Not rst.EOF
            If rst.Fields("ServiceInterval") > 0 Then
                ArrayOfServiceIntervals(i) = CDbl(rst.Fields("ServiceInterval"))
            End If
            rst.MoveNext
            i = i + 1
        Loop
    Else
        errMsg = "No service intervals were found in dbo_EquipType!" & _
        errMsg = errMsg & vbCrLf & str
        ' log this error
        mdlLog.AppendLog "BUILD-Array of Service Intervals", errMsg, LogCallerID, 5, LUCompanyInfoID()
        Failed = True
    End If
    
    rst.Close
    Set rst = Nothing
    
    If Not Failed Then
        BuildArrayOfServiceIntervals = True
    End If
    
PROC_EXIT:
    On Error Resume Next
    Exit Function

PROC_ERR:
    ' display the system error
    If err.Number <> 0 Then
        msg = ModuleName & " BuildArrayOfServiceIntervals" & vbCrLf & _
              "Error # " & CStr(err.Number) & " was generated by " & err.SOURCE & vbCrLf & err.Description
        mdlLog.AppendLog "PROC_ERR", msg, LogCallerID, 5, LUCompanyInfoID()
        MsgBox msg, , "Error", err.HelpFile, err.HelpContext
    End If
    Resume PROC_EXIT


End Function


Public Function HasServiceInterval(lngCustSiteID As Long, dblServiceInterval As Double) As Boolean
Dim msg
Dim SQL As String
Dim rst As DAO.Recordset
    
    On Error GoTo PROC_ERR
    HasServiceInterval = False
    SQL = _
        "SELECT dbo_CustSite.CustSiteID, dbo_EquipType.ServiceInterval " & _
        "FROM dbo_CustSite INNER JOIN (((dbo_Site INNER JOIN dbo_Station ON dbo_Site.SiteID = dbo_Station.SiteID) " & _
        "INNER JOIN dbo_Equipment ON dbo_Station.EquipmentID = dbo_Equipment.EquipmentID) " & _
        "INNER JOIN dbo_EquipType ON dbo_Equipment.EquipTypeID = dbo_EquipType.EquipTypeID) ON dbo_CustSite.SiteID = dbo_Site.SiteID " & _
        "GROUP BY dbo_CustSite.CustSiteID, dbo_EquipType.ServiceInterval " & _
        "HAVING (((dbo_CustSite.CustSiteID)=" & CStr(lngCustSiteID) & "));"

    Set rst = CurrentDb.OpenRecordset(SQL, dbOpenSnapshot, dbFailOnError + dbSeeChanges)
    If rst.RecordCount > 0 Then
        Do While Not rst.EOF
            If rst.Fields("ServiceInterval") = dblServiceInterval Then
                HasServiceInterval = True
                Exit Do
            End If
            rst.MoveNext
        Loop
    End If
    
    
PROC_EXIT:
    On Error Resume Next
    Exit Function

PROC_ERR:
    ' display the system error
    If err.Number <> 0 Then
        msg = ModuleName & " HasServiceInterval" & vbCrLf & _
              "Error # " & CStr(err.Number) & " was generated by " & err.SOURCE & vbCrLf & err.Description
        MsgBox msg, , "Error", err.HelpFile, err.HelpContext
    End If
    Resume PROC_EXIT

End Function


' this routine was moved into the toolbox as it's shared by UPDATE and ENABLED
Public Function HasMultiInProgress(ByVal lngCustSiteID As Long, ByVal dblServiceInterval As Double, ByRef errMsg As String) As Boolean
    Dim v As Variant
    Dim SQL As String
    Dim rst As DAO.Recordset
    Dim msg As String
    Dim Failed As Boolean
    Dim success As Boolean
    Dim iter As Integer
    
    On Error GoTo PROC_ERR
    HasMultiInProgress = True
    Failed = False
    
    ' ########## Check for multi-inspection order that are 'IN PROGRESS'
    ' ##########    with consideration to Service Interval

        ' look for in progress orders with identical service intervals
        SQL = _
            "SELECT InspectionOrderID " & _
            "FROM dbo_InspectionOrder " & _
            "WHERE (dbo_InspectionOrder.CustSiteID = " & CStr(lngCustSiteID) & " ) AND " & _
            "((dbo_InspectionOrder.InspectionStatusID <> 2) AND (dbo_InspectionOrder.InspectionStatusID <> 3))  AND " & _
            "(dbo_InspectionOrder.ServiceInterval = " & CStr(dblServiceInterval) & ")"
            
        Set rst = CurrentDb.OpenRecordset(SQL, dbOpenSnapshot, dbFailOnError + dbSeeChanges)
        If rst.RecordCount > 0 Then
            rst.MoveLast
            If rst.RecordCount > 1 Then
                Failed = True
                errMsg = _
                       "Unable to enable the site as the customer has" & vbCrLf & _
                       "outstanding inspection orders with a status of 'IN PROGRESS'." & vbCrLf & _
                       "Fix this issue by setting CANCELLED or COMPLETED." & vbCrLf & _
                       "The action was abort."
                mdlLog.AppendLog "Enable Customer Site.", errMsg, LULogCallerID(ModuleName), 5, LUCompanyInfoID()
            End If
            rst.Close
        End If
        Set rst = Nothing

    
    If Not Failed Then
        HasMultiInProgress = False
    End If
    
    
PROC_EXIT:
    On Error Resume Next
    Exit Function

PROC_ERR:
    ' display the system error
    If err.Number <> 0 Then
        msg = ModuleName & " CheckEnabledBy" & vbCrLf & _
              "Error # " & CStr(err.Number) & " was generated by " & err.SOURCE & vbCrLf & err.Description
        MsgBox msg, , "Error", err.HelpFile, err.HelpContext
    End If
    Resume PROC_EXIT
    
End Function

Function ExtractFileName(ByVal UNC_FileName As String) As String
    'Retrieve File Name with Extension
  ExtractFileName = Right(UNC_FileName, Len(UNC_FileName) - InStrRev(UNC_FileName, "\"))
End Function

'Sub GetPartOfFilePath(ByVal UNC_FileName)
'
'PURPOSE: Extract parts of a File Path
'SOURCE: www.TheSpreadsheetGuru.com
'
'Dim myPath As String
'Dim myOutput As String
'
'Take Off The File Extension
'  myOutput = Left(myPath, InStrRev(myPath, ".") - 1)
'
'Retrieve File Extension
'  myOutput = Right(myPath, Len(myPath) - InStrRev(myPath, "."))
'
'
'Retrieve File Name without Extension
'  myOutput = Mid(myPath, InStrRev(myPath, "\") + 1, InStrRev(myPath, ".") - InStrRev(myPath, "\") - 1)
'
'End Sub


