Attribute VB_Name = "_REPOSITORY"
Option Compare Database
Option Explicit

Private vReturnValue As Variant
Const ModuleName As String = "REPOSITORY"

    ' FORMAT DATE STRING FOR SQL EXPRESSION
    ' " (#" & Format(rst![CreatedOn], "mm/dd/yyyy hh:nn") & "#) "

' ######################################################################################
Public Function GENERTIC_FUNCTION(ByVal Value As Long) As Boolean
Dim Msg As String
    On Error GoTo PROC_ERR
PROC_EXIT:
    On Error Resume Next
    Exit Function

PROC_ERR:
    ' display the system error
    If err.Number <> 0 Then
        Msg = ModuleName & " GENERTIC_FUNCTION" & vbCrLf & _
              "Error # " & CStr(err.Number) & " was generated by " & err.Source & vbCrLf & err.Description
        MsgBox Msg, , "Error", err.HelpFile, err.HelpContext
    End If
    
    Resume PROC_EXIT
End Function
' ######################################################################################
Public Sub GENERTIC_SUBROUTINE(ByVal aID As Long)
    Dim s As String
    Dim SQL As String
    Dim rst As DAO.Recordset
    Dim dbs As DAO.Database
    Dim Msg As String

    On Error GoTo PROC_ERR
    
    If aID > 0 Then
        Set dbs = CurrentDb
        SQL = "Select * FROM dbo_TABLENAME"
        Set rst = dbs.OpenRecordset(SQL, dbOpenDynaset, dbFailOnError + dbSeeChanges)
        If Not IsNull(rst) Then
            With rst
                .AddNew
                ![ID] = aID
                .Update
                .Bookmark = .LastModified
                vReturnValue = ![ID]
            End With
        End If
    End If
    
PROC_EXIT:
    'Cleanup
    Set rst = Nothing
    Set dbs = Nothing
    On Error Resume Next
    Exit Sub

PROC_ERR:
    ' display the system error
    If err.Number <> 0 Then
        Msg = ModuleName & " GENERTIC_SUBROUTINE" & vbCrLf & _
              "Error # " & CStr(err.Number) & " was generated by " & err.Source & vbCrLf & err.Description
        MsgBox Msg, , "Error", err.HelpFile, err.HelpContext
    End If
    Resume PROC_EXIT
End Sub


Private Sub CmdDisplayReport_Click()
Dim Msg As String
Dim SQL As String
Dim d1 As Date
Dim d2 As Date
Dim s As String

On Error GoTo PROC_ERR

'    vReturnValue = 0
'    TOTRangeNonCore = 0
'    TOTRangeCore = 0
'
'
'    If IsNull(Me.Form![fIntervalSF]![Start]) Then
'        MsgBox "A start date is required", , "Program Attendance Report - ERROR"
'        Exit Sub
'    End If
'
'     'Filter String has dates in AMERICANIZED format
'    d1 = Format(Me.Form![fIntervalSF]![Start], "dd/mm/yyyy")
'    If Not IsNull(Me.Form![fIntervalSF]![End]) Then
'        d2 = Format(Me.Form![fIntervalSF]![End], "dd/mm/yyyy")
'    Else
'        d2 = Date
'    End If
'
'
'    d2 = mdlFunction.AdjustInterval(d2)
'
'     'clear the table
'    SQL = "DELETE * FROM t_ProgAttendance"
'    CurrentDb.Execute (SQL)
'
'    If LoadTable Then
'        s = d1 & "|" & d2 & "|" & CStr(TOTRangeNonCore) & "|" & CStr(TOTRangeCore)
'        DoCmd.OpenReport "RProgramAttendanceReport", acViewReport, "", , acNormal, s
'        vReturnValue = 1
'    End If
    
PROC_EXIT:
    On Error Resume Next
'    Me.Visible = False
    Exit Sub

PROC_ERR:
    ' display the system error
    If err.Number <> 0 Then
        Msg = ModuleName & " CmdDisplayReport_Click # " & str(err.Number) & " was generated by " & err.Source & vbCrLf & err.Description
        MsgBox Msg, , "Error", err.HelpFile, err.HelpContext
    End If
    vReturnValue = 0
    Resume PROC_EXIT

    
End Sub




'You can either
'
'Use a query that has parameters and specify values for parameters provided that the query uses parameters.
'
'Dim dbs As DAO.Database
'Dim qdf As DAO.QueryDef
'Dim prm As DAO.Parameter
'Dim rst As DAO.Recordset
'
'Set qdf = CurrentDb.QueryDefs("qry_SomeQueryWithParameters")
'
'qdf.Parameters("SomeParam").Value = "whatever"
'
'Set rst = qdf.OpenRecordset
'or
'
'Specify a query name as the command and use the Filter property on the recordset
'
'    Dim rst As DAO.Recordset
'    Dim rsFiltered As DAO.Recordset
'
'
'    Set rst = CurrentDb.OpenRecordset(qry_SomeQueryWithoutParameters)
'
'    rst.Filter = "field1 > 30"
'    Set rsFiltered = rst.OpenRecordset




'Sub RequeryX2()
'
' Dim dbsNorthwind As Database
' Dim qdfTemp As QueryDef
' Dim prmCountry As Parameter
' Dim rstView As Recordset2
'
' Set dbsNorthwind = OpenDatabase("Northwind.mdb")
' Set qdfTemp = dbsNorthwind.CreateQueryDef("", _
' "PARAMETERS ViewCountry Text; " & _
' "SELECT FirstName, LastName, Country FROM " & _
' "Employees WHERE Country = [ViewCountry] " & _
' "ORDER BY LastName")
' Set prmCountry = qdfTemp.Parameters!ViewCountry
'
' qdfTemp.Parameters!ViewCountry = "USA"
' Debug.Print "Data after initial query, " & _
' [ViewCountry] = USA; " "
' Set rstView = qdfTemp.OpenRecordset
' Do While Not rstView.EOF
' Debug.Print " " & rstView!FirstName & " " & _
' rstView!LastName & ", " & rstView!Country
' rstView.MoveNext
' Loop
'
' ' Change query parameter.
' qdfTemp.Parameters!ViewCountry = "UK"
' ' QueryDef argument must be included so that the
' ' resulting Recordset reflects the change in the query
' ' parameter.
' rstView.Requery qdfTemp
' Debug.Print "Requery after changing parameter, " & _
' "[ViewCountry] = UK"
' Do While Not rstView.EOF
' Debug.Print " " & rstView!FirstName & " " & _
' rstView!LastName & ", " & rstView!Country
' rstView.MoveNext
' Loop
'
' rstView.Close
' dbsNorthwind.Close
'
'End Sub




'What you describe can indeed be accomplished with an Access form bound to an ODBC linked table. What you need to do is create two controls on the form
'
'a hidden control bound to the field in the linked table, and
'a visible unbound control that the user can interact with.
'For example, say you have an ODBC linked table named [dbo_temperatures] pointing to a SQL Server table that stores temperature values in Celsius:
'
'-- (code to create the table in SQL Server Management Studio)
'CREATE TABLE dbo.temperatures (
'    id INT IDENTITY PRIMARY KEY,
'    observed DATETIME,
'    tempC INT)
'You also have two scalar functions in SQL Server to convert values from Celsius to Fahrenheit and vice-versa
'
'CREATE FUNCTION dbo.fnCtoF(@tempC AS INT) RETURNS INT
'AS
'BEGIN
'    DECLARE @t AS FLOAT;
'    SET @t = CONVERT(FLOAT, @tempC);
'    RETURN CONVERT(INT, (@t * 9 / 5) + 32);
'End
'and
'
'CREATE FUNCTION dbo.fnFtoC(@tempF AS INT) RETURNS INT
'AS
'BEGIN
'    DECLARE @t AS FLOAT;
'    SET @t = CONVERT(FLOAT, @tempF);
'    RETURN CONVERT(INT, (@t - 32) * 5 / 9);
'End
'On your form (bound to the linked table [dbo_temperatures]) you create
'
'a hidden text box named "txtTempC" that is bound to the [tempC] field, and
'a visible unbound text box named "txtTempF".
'The form has two private VBA functions to call the SQL Server functions
'
'Private Function getFahrenheit(t As Variant) As Variant
'    If IsNull(t) Then
'        getFahrenheit = Null
'    Else
'        Dim cdb As DAO.Database, qdf As DAO.QueryDef, rst As DAO.Recordset
'        Set cdb = CurrentDb
'        Set qdf = cdb.CreateQueryDef("")
'        qdf.Connect = cdb.TableDefs("dbo_temperatures").Connect
'        qdf.SQL = "SELECT dbo.fnCtoF(" & t & ") AS x"
'        qdf.ReturnsRecords = True
'        Set rst = qdf.OpenRecordset(dbOpenSnapshot)
'        getFahrenheit = rst!X
'        rst.Close
'        Set rst = Nothing
'        Set qdf = Nothing
'        Set cdb = Nothing
'    End If
'End Function
'and
'
'Private Function getCelsius(t As Variant) As Variant
'    If IsNull(t) Then
'        getCelsius = Null
'    Else
'        Dim cdb As DAO.Database, qdf As DAO.QueryDef, rst As DAO.Recordset
'        Set cdb = CurrentDb
'        Set qdf = cdb.CreateQueryDef("")
'        qdf.Connect = cdb.TableDefs("dbo_temperatures").Connect
'        qdf.SQL = "SELECT dbo.fnFtoC(" & t & ") AS x"
'        qdf.ReturnsRecords = True
'        Set rst = qdf.OpenRecordset(dbOpenSnapshot)
'        getCelsius = rst!X
'        rst.Close
'        Set rst = Nothing
'        Set qdf = Nothing
'        Set cdb = Nothing
'    End If
'End Function
'Then you can use the On Current event of the Form to populate the Fahrenheit text box
'
'Private Sub Form_Current()
'    Me.txtTempF.Value = getFahrenheit(Me.txtTempC.Value)
'End Sub
'and the After Update event of the Fahrenheit text box to update the Celsius text box.
'
'Private Sub txtTempF_AfterUpdate()
'    Me.txtTempC.Value = getCelsius(Me.txtTempF.Value)
'End Sub
'Because the Celsius text box is bound to the [tempC] field, the change will be written back to the table when the record is saved.
